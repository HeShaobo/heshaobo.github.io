<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://heshaobo.github.io</id>
    <title>unifix</title>
    <updated>2022-03-22T11:36:08.790Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://heshaobo.github.io"/>
    <link rel="self" href="https://heshaobo.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://heshaobo.github.io/images/avatar.png</logo>
    <icon>https://heshaobo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, unifix</rights>
    <entry>
        <title type="html"><![CDATA[index0]]></title>
        <id>https://heshaobo.github.io/post/index0/</id>
        <link href="https://heshaobo.github.io/post/index0/">
        </link>
        <updated>2021-12-11T08:34:24.000Z</updated>
        <content type="html"><![CDATA[<p>我原本在medium （https://medium.com/@heshaobo2012）上面写作，越来越感觉medium的编辑习惯对程序员非常不友好，连最基本的代码高亮都无法支持，每次需要插入代码都需要先去gist创建一段代码段贴进来，效率非常低下</p>
<p>今天偶然发现之前我还在github.io上面创建过一个博客空间，使用了Gridea工具，支持mardown，支持代码高亮，还有mac客户端直接本地编辑之后一键发布，这不就是为程序员量身打造的发布平台吗，所以后续的文章我应该都会在这边发布</p>
<p>接下来的日子里，我在这里发布的主题应该会包含以下：</p>
<ul>
<li>linux内核学习笔记</li>
<li>linux工具使用，线上问题分析定位过程总结</li>
<li>python生态的一些东西</li>
<li>mysql相关的东西</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[coroutine]微信开源协程库libco源码鉴赏]]></title>
        <id>https://heshaobo.github.io/post/coroutinewei-xin-kai-yuan-xie-cheng-ku-libco-yuan-ma-jian-shang/</id>
        <link href="https://heshaobo.github.io/post/coroutinewei-xin-kai-yuan-xie-cheng-ku-libco-yuan-ma-jian-shang/">
        </link>
        <updated>2021-08-11T08:52:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-前言">1. 前言</h2>
<p>libco是几年前腾讯微信团队开源的一个C/C++协程库，据说微信后台大量在使用这个库，通过几个简单的接口就能实现协程的创建/调度，同时基于epoll/kqueue实现了一个事件反应堆，再加上sys_call（系统调用）hook技术，以此给开发者提供同步/异步的开发方法，总的来说，这个库能提供以下特性：</p>
<ul>
<li>无需侵入业务逻辑，把多进程、多线程服务改造成协程服务</li>
<li>支持gethostbyname、mysqlclient、ssl等常用第三库</li>
<li>同时支持共享栈及独立栈两种模式</li>
<li>类pthread接口设计，通过co_create、co_resume等简单清晰接口即可完成协程的创建与恢复</li>
<li>基于epoll/kqueue实现的小而轻的网络框架，基于时间轮盘实现的高性能定时器</li>
</ul>
<p>地址：<a href="https://github.com/Tencent/libco">https://github.com/Tencent/libco</a></p>
<p>为什么会去翻libco这个项目，主要是最近在看协程方面的东西，打算看完写一个[coroutine]系列出来，其中的重心将会是python的gevent协程库，python要实现协程将要处理两个层次的东西，一个是python语言层，这一层是应用开发者可以看到的，这一层主要解决python函数栈桢的调度，另一层是解释器，greenlet即在C语言层面实现了协程调度。</p>
<p>在了解这个东西的同时，我一边观察了业界同类设计作品，并进行了横行对比，其中在C实现的调度器这一块，我就拿了云风的coroutine库、微信的libco、python的greenlet来进行对比，这篇文章就先好好讲一讲libco，周末花了一点时间捋了一遍，总的来说libco跟业界对比并没有特别出彩的地方，用到的一些核心算法也只能算是平均水平。关于源码本身的剖析，网络上已经有很多文章，所以我不打算花大量篇副去讲源码本身的分析，只是拿其中作为一个协程库应该有的几个核心的东西出来聊一下，其中包括以下四大主题：</p>
<ul>
<li>协程调度器的实现模式，共享栈/独立栈</li>
<li>基于epoll实现的事件反应堆</li>
<li>基于C语言如何实现系统调用的hook</li>
<li>timer定时器的核心算法</li>
</ul>
<h2 id="2-协程">2. 协程</h2>
<p>协程的本质是用户态下的多任务调度，协程间的切换不需要内核介入，相对于内核提供的基于抢占式的线程调度模型（即当前线程在执行过程中任意时刻都有可能被内核强行切走），协程模型提供的是协作式切换，即不同协程的切换都是由用户显式发起的</p>
<p>这里面一个核心问题就是：当前协程被切换走了之后还能不能重新被切回来，协程现场会不会被破坏，比如在C语言环境下，当前函数的上下文结构起码包含两个重要的现场信息，一个是CPU各个寄存器状态，另一个就是当前函数的栈桢，关于栈桢的东西可以看看这篇文章</p>
<p><a href="https://www.cnblogs.com/sddai/p/9762968.html">C函数调用过程原理及函数栈帧分析</a></p>
<p>协程界基本上根据是否基于栈桢的调度分为两个派系，一种是无栈协程，一种是有栈协程，今天这里不讲无栈协程，主要聊一聊有栈</p>
<p>有栈协程比较符合人类的思维习惯，在协程内开发者可以使用串行逻辑进行编写，比如先处理A，等A处理完再处理B，类比线程的处理方式，这种方式的实现思想是把当前栈桢跟当前协程绑定在一起，libco就是这样的实现方式，当协程进行切换的时候，当前函数所在的栈桢会被一起切走并且保护起来，然后把栈顶指针SP指向下一个协程的栈顶，协程与协程之前的栈桢互不影响，每个人都有自己的上下文,从栈的使用角度出现，一般有以下两种实现方式</p>
<ul>
<li>独立栈</li>
</ul>
<p>每个协程在创建的时候都从堆上申请一块内存作为自己的栈，这种做法的好处就是简单，但是问题在于栈大小该如何确定，设得太小了容易溢出，设得太大了浪费内存，这种方式下通常需要开发者自己根据业务去设置</p>
<ul>
<li>共享栈</li>
</ul>
<p>这种方式下，主线程会预先创建一块足够大的内存做为所有人都可以使用的栈，每个协程的栈都跑在这块内存上面，跟独立栈的区别在于：当进行协程调度的时候，调度算法会计算出当前协程使用了多少栈空间，计算方式也很简单，当前时刻的SP指针指向的就是栈项，这个栈顶与栈底（协程刚创建时记录下来）的差就是当前协程的栈使用量，然后把这个内存拷贝出来，根据大小在堆上申请一块动态内存保存起来，接着把下一个协程的内存拷进这个共享栈再调度，相比之下，共享栈就是按量计费，用多少申请多少，比独立栈省内存，但缺点也是有的，协程切换需要经历两次内存拷贝，栈用量少的话还好，如果有些函数在栈上开辟了一大堆临时数组，这些数据都得算到栈里面，内存间拷贝会比较消耗资源</p>
<h4 id="思考有没有更优秀的解决方案">思考：有没有更优秀的解决方案</h4>
<p>以上，其实共享栈的出现本质上是因为独立栈相对来说浪费空间，因为他要求对每个协程都有一个固定大小且“固定地址”的空间，固定大小这个比较容易理解，重点在于：固定地址</p>
<p>以C语言为例，在上面我贴的关于函数栈的分析里面可以知道，栈里面会保个栈帧的基地址（EBP），在帧片段会基于这个地址通过偏移操作来获得各种入参以及返回地址，正是由于有了这种栈内的“指针引用”，使得假如我们需要对栈空闲进行扩展，是无法直接申请新的内存空间进行替换的，否则，栈内的EBP指针将变成野指针，更甚者，在协程里面的子函数调用里面，如果对局部变量使用的是指针引用的形式，同样也会引发这种问题</p>
<p>一种激进的想法是：在栈扩展的时间进行栈回溯，找出栈内那些被引用的地址并逐个替换之，Golang即是使用这种方式，由于有了自身编译器的加持，Golang可以实现更高效的所谓“连续栈”，可以在独立栈的基础上进行运行时动态栈增长，这得益于Golang内置编译器对代码段的特殊处理，在运行时进入一个子函数之前就可以判断出是否需要进行栈增长，在需要增长的时候，通过申请新的内存块，把栈内容复制到新的内存块中，复制的过程中即需要对栈内指针引用进行替换，对Golang的理解不深（如果描述有误欢迎指正-），详细内容可以看以下文章：</p>
<p><a href="https://juejin.cn/post/6844903969253244936">golang核心原理-协程栈</a></p>
<h4 id="libco的协程实现">libco的协程实现</h4>
<p>libco支持以上说的独立栈和共享栈两种方案，核心实现源码是co_routine.cpp文件，支持多线程，每个线程负责一个routine实例，支持协程内嵌套创建子协程，这是通过协程调度器的一个递归栈来实现的</p>
<p>对于协程调度的细节，网络上有相当多的剖析文章，这里就不再重复了，在网上找了一篇讲得比较详细的文章<br>
微信 libco 协程库源码分析</p>
<p><a href="https://www.cyhone.com/articles/analysis-of-libco/">微信 libco 协程库源码分析</a></p>
<p>本文的重点，我将着重分析libco的事件机制，包括事件反应堆以及定时器调度算法</p>
<h2 id="3-事件反应堆">3. 事件反应堆</h2>
<p>作为一个拿得出手的协程库实现，协程调度只是其中最基础的功能，如果仅仅依靠协程调度器，其实几乎做不了太多实用的事情，我们必须至少解决以下问题:</p>
<h4 id="io阻塞">IO阻塞</h4>
<p>没错，与多线程最大的不同在于，协程间的切换完全处于用户态，这意味着如果其中一个协程使用了阻塞的系统调用，比如读socket，如果数据还未到达，则当前进程将被系统挂起，这期间所有协程都无法得到执行，为了解决这个问题，一般目前成熟的协程库都会配置实现一套多路复用机制，将IO改成非阻塞，在协程进行IO读写的时候，把读写的事件挂到反应堆上去，然后把CPU让给其他协程去运行，当事件到达的时候，再通过反应堆把协程调度回来，各种语言的实现比如python的gevnet，Golang，libco目前都使用这种方式，libco对于事件反应堆的实现，基本上干了以下几件事情</p>
<ul>
<li>linux下使用epoll封装了一套事件机制，把epoll的事件与协程进行绑定，基于事件进行协程的调度，核心实现在co_routine.cpp</li>
<li>对系统调用函数的链接符号进行hook，无需入侵业务即可完成协程化改造</li>
<li>实现了一套定时器调度算法，以支持IO的超时等待等特性</li>
</ul>
<p>记得我开头写的吗，libco“支持gethostbyname、mysqlclient、ssl等常用第三库”，非业务入侵，即你该怎么用mysql还是怎么用，上了libco之后不需要你去关心IO是不是阻塞的，这是因为libco对系统调用（sys_call）进行了劫持，在运行时，业务代码在调用sys_call（比如socket的read, write等操作）时，将被重定向到libco自己实现的函数入口，这些入口在co_hook_sys_call.cpp里面实现，业务代码的IO调用，实际上是被转到这些函数里面，把这些请求挂到epoll上面，然后把当前CPU让给其他协程去执行，这样实现之后，从业务角度看起来，当前的代码似乎是被IO阻塞住了，直到有事件产生才从sys_call里面返回，实现上，在这段“阻塞”期间，CPU是让给其他协程在运行的，以此实现单进程多并发</p>
<h2 id="4-定时器调度">4. 定时器调度</h2>
<p>看起来很完美，但实际上还有一个非常重要的问题需要解决：timeout</p>
<p>网络IO的调用过程通常都会有过程超时的场景需要处理，比如connectionTimeout连接超时、readTimeout读超时等，通常在阻塞型的IO调用里，sys_call接口都会提供一个timeout参数供调用者设置，在一定时间内如果无法数据还没到达，进程将会被重新唤醒，并返回一个特定的错误码，从而避免永久等待下去，这个过程内核通常会为其生成一个定时器事件，添加到定时器队列里面，时间到了之后由内核去唤醒进程，从sys_call返回</p>
<p>但是到了协程这里，由于我们的IO改成了非阻塞，调用过程是立即返回的，不存在所谓的超时，比如socket.read，对epoll来说，这个read调用是立即返回的，为了对业务层实现非入侵的协程支持，这通常要求事件反应堆还要额外实现一个定时器调度处理，题外话，其实理论上所有基于多路复用的高性能服务，比如nginx、redis，都需要实现这样一套定时器调度器</p>
<p>定时器的本质就是给一个事件设置一个过期时间，当时间到了之后，执行这个事件（回调），时间是流逝的，所以从实现上，我们需要在每个时间嘀嗒里面去寻找出当前时刻已到期的事件，并拿出来执行，把这个问题抽象一下，我们把过期时间设置为时间戳，给你一堆事件，每个事件都有不同的时间戳，在每个周期，我们需要<br>
寻找出比当前时刻小的那些时间戳，这其实就是一个topK算法，业界对定时器通常有以下几种解法：</p>
<h4 id="最小堆">最小堆</h4>
<p>按事件的时间戳作为输入，维护一个最小二叉堆，那么堆顶就是最小的时间戳，我们每次只要拿堆顶元素来与当前时刻比较即可，即元素的时间复杂度是O(1)， 插入是O(lgN)，这种办法的缺点就是数组长度是固定的，假如定时器事件很大的话，需要做数组动态扩展，是比较低效的，据我所知libevent在使用这种方式</p>
<h4 id="红黑树">红黑树</h4>
<p>红黑树也是用得比较多的定时器调度算法，红黑树是平衡二叉树，同时跟二叉堆相比最大的优势是可以无限扩展，我们用事件的时间戳作为输入，保持左子树的数小于等于右子树，那些左子树的最左叶子节点就是时小的时间戳，取最左叶子节点时间复杂度是O(lgN)，插入及更新都是O(lgN)，目前nginx在使用这种方式</p>
<h4 id="时间轮">时间轮</h4>
<p>时间轮据我所知最早使用是在linux内核上面，简单来说就是维护一个时间轮盘（首尾连接的一个数组），轮上面的一个元素就是一个时间刻度，把不同到期时间的事件挂到不同的刻度上，我们每个时间嘀嗒往前走一步，非常容易就能把当前时刻下的到期事件取出来，非常高效，而且可以有多个时间轮，每个时间轮的刻度单位不同，从而可以支持非常大的过期时间，就像家里的自来水表一样，详细的时间轮算法解析如下：</p>
<p><a href="https://zhuanlan.zhihu.com/p/84502375">时间轮定时器</a></p>
<p>libco使用的是时间轮算法，但是只有一个轮，这个轮上面有60000个刻度，libco使用epoll设置的timeout是1ms，所以一个时间嘀嗒是1ms，总共支持60秒的过期时间</p>
<p>这里要说一点，libco使用epoll默认timeout是1ms，也就是说没有事件发生的事情，最久1ms就要醒来一次，1秒钟就要被唤醒1000次，如果跑多进程，那其实对系统来说，上下文切换还是有一定的资源消耗的，而且linux对epoll的timeout使用的是粒度比较粗的定时器，最小精度是1ms，也就是说是没有办法保证准时在1ms进行唤醒的，所以基于epoll timeout作为时间嘀嗒的timeout精度自然也就没办法保持到1ms级别</p>
<p>以上问题，做为优化方案，我觉得libco其实没必要把epoll timeout设得这么小，例如可以在进入epoll_wait之前就提前算出离我最近的定时器将在什么时候到期，比如会在10ms之后到期，那我完全可以epoll休眠10ms再醒来；至于如何提前推算最近的到期时间，可以把时间轮映射到一个bigmap上面，一个bit代表一个刻度，如果这个刻度上面挂了事件，就把bit置位，然后遍历一个这个bitmap的某些区域，就可以快速推算出最近到期的事件</p>
<h2 id="5-总结">5. 总结</h2>
<p>总体而言，libco算是一个中规中矩的协程框架，不过作为学习资料，是比较值得一看的</p>
]]></content>
    </entry>
</feed>